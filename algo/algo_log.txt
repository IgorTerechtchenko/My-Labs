05_leap_year - DONE:
    9.05.16
    Просто проверка условия.

08_easy_task - DONE:
    9.05.16
    Перемножил меньшие и большие элементы, отдал больший результат.

12_donny - DONE:
    10.05.16
    Опытным путем установил, что выигрышная цифра - последняя. Если последняя цифра - 0,
    отказ от игры.

03_palindrom - DONE:
    10.05.16
    Сначала попытался решить в лоб: нашел первый среди подстрок непалиндром,
    однако, решение не прошло по времени. Переписал на плюсах - то же самое.
    11.05.16
    Изменил алгоритм: теперь проверяю, не состоит ли строка из повторений одного символа.
    Если состоит, вывожу -1. Если нет, итерируюсь в бесконечном цикле, каждую итерацию
    сравнивая строку с перевернутой строкой. Если они равны, удаляю последний элемент.
    Если нет, печатаю -1.

17_chess_game - DONE:
    11.05.16
    Поразмыслив, предположил, что первый игрок всегда проигрывает, если ладьи стоят диагонально
    друг к другу. Ладьи стоят диагонально, если соответствующие их координаты отличаются на одно
    и то же значение.

19_bignum - DONE:
    12.05.16
    Записал числа в массив. Делю magic_number на числа массива, пока не получится один.
    Если получится - "YES". Возможно, есть ошибка в тестах.
    17.05.16
    Перебрал все комбинации множителей. Сдал, но все еще интересно, почему оригинальное решение
    не работало.

14_next - DONE:
    13.05.16
    Алгоритм заключается в том, чтобы найти длиннейший невозрастающий суффикс строки,
    и отделить его от строки. Теперь остаток строки - a, а суффикс - b. Необходимо найти
    первый с конца элемент b, больший последнего элемента a, и поменять их местами. Затем
    отсортировать b, и объеденить a и b.

07_addition:
    15.05.16
    Записываю пары различных соединенных вершин в множество, таким образом исключая циклы.
    Затем, зная размер множества, вычисляю сколько ребер надо добавить, чтобы их количество
    стало ранвно количеству ребер - 1. Непонятно, при каких условиях ответа может не быть.
    17.05.16
    Задача сводится к тому, чтобы найти количество компонент связности путем обхода графа в
    глубину. Ответ - их количество минус один.
